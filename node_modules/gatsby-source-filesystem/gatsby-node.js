"use strict";

var _stringify = require("babel-runtime/core-js/json/stringify");

var _stringify2 = _interopRequireDefault(_stringify);

var _extends2 = require("babel-runtime/helpers/extends");

var _extends3 = _interopRequireDefault(_extends2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var path = require("path");
var md5File = require("md5-file");
var fs = require("fs");
var prettyBytes = require("pretty-bytes");
var slash = require("slash");
var chokidar = require("chokidar");
var mime = require("mime");

function readFile(file, pluginOptions, cb) {
  var slashed = slash(file);
  var slashedFile = (0, _extends3.default)({}, path.parse(slashed), {
    absolutePath: slashed
  });
  md5File(slashedFile.absolutePath, function (md5Err, contentDigest) {
    fs.stat(slashedFile.absolutePath, function (statErr, stats) {
      // Stringify date objects.
      var newFile = JSON.parse((0, _stringify2.default)((0, _extends3.default)({
        // Don't actually make the File id the absolute path as otherwise
        // people will use the id for that and ids shouldn't be treated as
        // useful information.
        id: `${slashedFile.absolutePath} absPath of file`,
        contentDigest: contentDigest,
        children: [],
        parent: `___SOURCE___`,
        mediaType: mime.lookup(slashedFile.ext),
        type: `File`,
        sourceName: pluginOptions.name,
        absolutePath: slashedFile.absolutePath,
        relativePath: slash(path.relative(pluginOptions.path, slashedFile.absolutePath)),
        extension: slashedFile.ext.slice(1).toLowerCase(),
        size: stats.size,
        prettySize: prettyBytes(stats.size),
        modifiedTime: stats.mtime,
        accessTime: stats.atime,
        changeTime: stats.ctime,
        birthTime: stats.birthtime
      }, slashedFile, stats)));
      cb(null, newFile);
    });
  });
}

exports.sourceNodes = function (_ref, pluginOptions) {
  var boundActionCreators = _ref.boundActionCreators,
      getNode = _ref.getNode,
      hasNodeChanged = _ref.hasNodeChanged;
  var createNode = boundActionCreators.createNode,
      updateSourcePluginStatus = boundActionCreators.updateSourcePluginStatus;

  updateSourcePluginStatus({
    plugin: `source-filesystem --- ${pluginOptions.name}`,
    ready: false
  });
  var watcher = chokidar.watch(pluginOptions.path, {
    ignored: [`**/*.un~`, `**/.gitignore`, `**/.npmignore`, `**/.babelrc`, `**/yarn.lock`, `**/node_modules`, `../**/dist/**`]
  });

  watcher.on(`add`, function (path) {
    // console.log("Added file at", path)
    readFile(path, pluginOptions, function (err, file) {
      // Only create node if the content digest has changed.
      if (!getNode(file.id) || hasNodeChanged(file.id, file.contentDigest)) {
        createNode(file);
      } else {
        // console.log("not creating node cause it already exists", file.id)
      }
    });
  });
  watcher.on(`change`, function (path) {
    console.log("changed file at", path);
    readFile(path, pluginOptions, function (err, file) {
      // Only create node if the content digest has changed.
      if (!getNode(file.id) || hasNodeChanged(file.id, file.contentDigest)) {
        createNode(file);
      }
    });
  });
  watcher.on(`ready`, function () {
    updateSourcePluginStatus({
      plugin: `source-filesystem --- ${pluginOptions.name}`,
      ready: true
    });
  });

  // TODO add delete support.
  return;
};