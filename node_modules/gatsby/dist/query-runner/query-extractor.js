"use strict";

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _babelTraverse = require("babel-traverse");

var _babelTraverse2 = _interopRequireDefault(_babelTraverse);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var fs = require("fs");
// Traverse is a es6 module...

var babylon = require("babylon");
var Promise = require("bluebird");
var _ = require("lodash");

var apiRunnerNode = require("../utils/api-runner-node");

var readFileAsync = Promise.promisify(fs.readFile);

module.exports = function () {
  var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(filePath) {
    var fileStr, ast, transpiled, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, item, tmp, query, declaration, name, type, chunks, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, quasi;

    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return readFileAsync(filePath, `utf-8`);

          case 2:
            fileStr = _context.sent;
            ast = void 0;
            // Preprocess and attempt to parse source; return an AST if we can, log an
            // error if we can't.

            _context.next = 6;
            return apiRunnerNode(`preprocessSource`, {
              filename: filePath,
              contents: fileStr
            });

          case 6:
            transpiled = _context.sent;

            if (!transpiled.length) {
              _context.next = 45;
              break;
            }

            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _iteratorError = undefined;
            _context.prev = 11;
            _iterator = (0, _getIterator3.default)(transpiled);

          case 13:
            if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
              _context.next = 28;
              break;
            }

            item = _step.value;
            _context.prev = 15;
            tmp = babylon.parse(item, {
              sourceType: `module`,
              plugins: [`*`]
            });

            ast = tmp;
            return _context.abrupt("break", 28);

          case 21:
            _context.prev = 21;
            _context.t0 = _context["catch"](15);

            console.info(_context.t0);
            return _context.abrupt("continue", 25);

          case 25:
            _iteratorNormalCompletion = true;
            _context.next = 13;
            break;

          case 28:
            _context.next = 34;
            break;

          case 30:
            _context.prev = 30;
            _context.t1 = _context["catch"](11);
            _didIteratorError = true;
            _iteratorError = _context.t1;

          case 34:
            _context.prev = 34;
            _context.prev = 35;

            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }

          case 37:
            _context.prev = 37;

            if (!_didIteratorError) {
              _context.next = 40;
              break;
            }

            throw _iteratorError;

          case 40:
            return _context.finish(37);

          case 41:
            return _context.finish(34);

          case 42:
            if (ast === undefined) {
              console.error(`Failed to parse preprocessed file ${filePath}`);
            }
            _context.next = 46;
            break;

          case 45:
            try {
              ast = babylon.parse(fileStr, {
                sourceType: `module`,
                sourceFilename: true,
                plugins: [`*`]
              });
            } catch (e) {
              console.log(`Failed to parse ${filePath}`);
              console.log(e);
            }

          case 46:

            // Get query for this file.
            query = void 0;
            _context.t2 = _babelTraverse2.default;
            _context.t3 = ast;
            _context.t4 = {
              ExportNamedDeclaration(path, state) {
                // cache declaration node
                declaration = path.node.declaration.declarations[0];
                // we're looking for a ES6 named export called "pageQuery"

                name = declaration.id.name;

                if (name === `pageQuery`) {
                  type = declaration.init.type;

                  if (type === `TemplateLiteral`) {
                    // most pageQueries will be template strings
                    chunks = [];
                    _iteratorNormalCompletion2 = true;
                    _didIteratorError2 = false;
                    _iteratorError2 = undefined;

                    try {
                      for (_iterator2 = (0, _getIterator3.default)(declaration.init.quasis); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        quasi = _step2.value;

                        chunks.push(quasi.value.cooked);
                      }
                    } catch (err) {
                      _didIteratorError2 = true;
                      _iteratorError2 = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                          _iterator2.return();
                        }
                      } finally {
                        if (_didIteratorError2) {
                          throw _iteratorError2;
                        }
                      }
                    }

                    query = chunks.join(``);
                  } else if (type === `StringLiteral`) {
                    // fun fact: CoffeeScript can only generate StringLiterals
                    query = declaration.init.extra.rawValue;
                  }
                  console.time(`graphql query time`);
                }
              }
            };
            (0, _context.t2)(_context.t3, _context.t4);


            // Ensure query is a string and trim whitespace
            if (!_.isString(query)) {
              query = "";
            }
            query = _.trim(query);

            return _context.abrupt("return", query);

          case 54:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, undefined, [[11, 30, 34, 42], [15, 21], [35,, 37, 41]]);
  }));

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}();