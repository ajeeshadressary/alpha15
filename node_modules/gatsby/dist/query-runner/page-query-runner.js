"use strict";

/***
 * Jobs of this module
 * - Ensure on bootstrap that all invalid page queries are run and report
 *   when this is done
 * - Watch for when a page's query is invalidated and re-run it.
 ***/

var _ = require("lodash");
var Promise = require("bluebird");

var _require = require("../redux"),
    store = _require.store;

var queryRunner = require("./query-runner");
var checkpointsPromise = require("../utils/checkpoints-promise");

var queuedDirtyActions = [];
// Don't start running queries until we've reached the BOOTSTRAP_STAGE of
// QUERY_RUNNER.
var active = false;
var callbacks = [];
module.exports = function (cb) {
  callbacks.push(cb);
};

checkpointsPromise({
  events: [`COMPONENT_QUERIES_EXTRACTION_FINISHED`]
}).then(function () {
  active = true;
  var state = store.getState();

  // Run queued dirty nodes now that we're active.
  queuedDirtyActions = _.uniq(queuedDirtyActions, function (a) {
    return a.payload.id;
  });
  findAndRunQueriesForDirtyPaths(queuedDirtyActions).then(function () {
    // Find paths without data dependencies and run them (just in case?)
    var paths = findPathsWithoutDataDependencies();
    // Run these pages
    Promise.all(paths.map(function (path) {
      var page = state.pages.find(function (p) {
        return p.path === path;
      });
      var component = state.pageComponents[page.component];
      return queryRunner(page, component);
    })).then(function () {
      // Tell everyone who cares that we're done.
      callbacks.forEach(function (cb) {
        return cb();
      });
    });
  });
});

store.subscribe(function () {
  var state = store.getState();

  if (state.lastAction.type === "CREATE_NODE") {
    queuedDirtyActions.push(state.lastAction);
    debouncedProcessQueries();
  }
  // Also debounce on UPDATE_NODE so we're sure all node processing is done
  // before re-running a query.
  //
  // PS. prediction to future selves, this method of debouncing data processing
  // will break down bigly once data processing pipelines get really complex or
  // plugins introduce very expensive steps.
  if (state.lastAction.type === "UPDATE_NODE") {
    debouncedProcessQueries();
  }
});

var findPathsWithoutDataDependencies = function findPathsWithoutDataDependencies() {
  var state = store.getState();
  var allTrackedPaths = _.uniq(_.flatten(_.concat(_.values(state.pageDataDependencies.nodes), _.values(state.pageDataDependencies.connections))));

  // Get list of paths not already tracked and run the queries for these
  // paths.
  return _.difference(state.pages.map(function (p) {
    return p.path;
  }), allTrackedPaths);
};

var findAndRunQueriesForDirtyPaths = function findAndRunQueriesForDirtyPaths(actions) {
  var state = store.getState();
  var dirtyPaths = [];
  actions.forEach(function (action) {
    var node = state.nodes[action.payload.id];
    // Find invalid pages.
    if (state.pageDataDependencies.nodes[node.id]) {
      dirtyPaths = dirtyPaths.concat(state.pageDataDependencies.nodes[node.id]);
    }
    // Find invalid connections
    if (state.pageDataDependencies.connections[node.type]) {
      dirtyPaths = dirtyPaths.concat(state.pageDataDependencies.connections[node.type]);
    }
  });

  if (dirtyPaths.length > 0) {
    console.log(`all pages invalidated by node change`, _.uniq(dirtyPaths));

    // Run these pages
    return Promise.all(_.uniq(dirtyPaths).map(function (path) {
      var page = state.pages.find(function (p) {
        return p.path === path;
      });
      var component = state.pageComponents[page.component];
      return queryRunner(page, component);
    }));
  } else {
    return Promise.resolve();
  }
};

var debouncedProcessQueries = _.debounce(function () {
  if (active) {
    queuedDirtyActions = _.uniq(queuedDirtyActions, function (a) {
      return a.payload.id;
    });
    findAndRunQueriesForDirtyPaths(queuedDirtyActions);
    queuedDirtyActions = [];
  }
}, 25);