"use strict";

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _toConsumableArray2 = require("babel-runtime/helpers/toConsumableArray");

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _extends2 = require("babel-runtime/helpers/extends");

var _extends3 = _interopRequireDefault(_extends2);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ = require("lodash");

var _require = require("graphql"),
    GraphQLObjectType = _require.GraphQLObjectType,
    GraphQLNonNull = _require.GraphQLNonNull,
    GraphQLID = _require.GraphQLID,
    GraphQLList = _require.GraphQLList,
    GraphQLString = _require.GraphQLString;

var select = require("unist-util-select");
var path = require("path");
var Promise = require("bluebird");
var mime = require("mime");
var slash = require("slash");

var apiRunner = require("../utils/api-runner-node");

var _require2 = require("./infer-graphql-type"),
    inferObjectStructureFromNodes = _require2.inferObjectStructureFromNodes;

var _require3 = require(`./infer-graphql-input-fields`),
    inferInputObjectStructureFromNodes = _require3.inferInputObjectStructureFromNodes;

var nodeInterface = require("./node-interface");

var _require4 = require("../redux"),
    store = _require4.store,
    getNodes = _require4.getNodes,
    getNode = _require4.getNode,
    getNodeAndSavePathDependency = _require4.getNodeAndSavePathDependency;

var _require5 = require("../redux/actions/add-page-dependency"),
    addPageDependency = _require5.addPageDependency;

module.exports = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
  return _regenerator2.default.wrap(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          return _context.abrupt("return", new Promise(function (resolve) {
            var processedTypes = {};

            // Identify node types in the data.
            var types = _.groupBy(getNodes(), function (node) {
              return node.type;
            });

            var createNodeFields = function createNodeFields(type) {
              var defaultNodeFields = {
                id: {
                  type: new GraphQLNonNull(GraphQLID),
                  description: `The id of this node.`
                },
                type: {
                  type: GraphQLString,
                  description: `The type of this node`
                },
                parent: {
                  type: nodeInterface,
                  description: `The parent of this node.`,
                  resolve(node, a, context) {
                    return getNodeAndSavePathDependency(node.parent, context.path);
                  }
                },
                children: {
                  type: new GraphQLList(nodeInterface),
                  description: `The children of this node.`,
                  resolve(node, a, context) {
                    return node.children.map(function (id) {
                      return getNodeAndSavePathDependency(id, context.path);
                    });
                  }
                }
              };

              var inferredFields = inferObjectStructureFromNodes({
                nodes: type.nodes,
                types: _.values(processedTypes),
                allNodes: getNodes()
              });

              return (0, _extends3.default)({}, defaultNodeFields, inferredFields, type.fieldsFromPlugins);
            };

            // Create node types and node fields for nodes that have a resolve function.
            Promise.all(_.map(types, function (nodes, typeName) {
              return new Promise(function (typeResolve) {
                var nodeType = {
                  name: typeName,
                  nodes
                };
                apiRunner(`extendNodeType`, {
                  type: nodeType,
                  allNodes: getNodes()
                }).then(function (fieldsFromPlugins) {
                  var mergedFieldsFromPlugins = _.merge.apply(_, (0, _toConsumableArray3.default)(fieldsFromPlugins));
                  nodeType.fieldsFromPlugins = mergedFieldsFromPlugins;

                  var inputArgs = inferInputObjectStructureFromNodes(nodes, ``, typeName);

                  nodeType.nodeObjectType = new GraphQLObjectType({
                    name: typeName,
                    description: `Node of type ${typeName}`,
                    fields: function fields() {
                      return createNodeFields(nodeType);
                    },
                    interfaces: [nodeInterface],
                    isTypeOf: function isTypeOf(value) {
                      return value.type === typeName;
                    }
                  });

                  nodeType.node = {
                    name: typeName,
                    type: nodeType.nodeObjectType,
                    args: (0, _extends3.default)({}, inputArgs),
                    resolve(a, args, context) {
                      var runSift = require("./run-sift");
                      var latestNodes = _.filter(getNodes(), function (n) {
                        return n.type === typeName;
                      });
                      return runSift({
                        args,
                        nodes: latestNodes,
                        path: context.path
                      });
                    }
                  };

                  nodeType.field = {
                    name: _.camelCase(`${typeName} field`),
                    type: nodeType.nodeObjectType,
                    resolve: function resolve(node, a, context, _ref2) {
                      var fieldName = _ref2.fieldName;

                      var fieldValue = node[fieldName];
                      var sourceFileNode = _.find(getNodes(), function (n) {
                        return n.type === `File` && n.id === node.parent;
                      });

                      // Then test if the field is linking to a file.
                      if (_.isString(fieldValue) && mime.lookup(fieldValue) !== `application/octet-stream`) {
                        var fileLinkPath = slash(path.resolve(sourceFileNode.dir, fieldValue));
                        var linkedFileNode = _.find(getNodes(), function (n) {
                          return n.type === `File` && n.absolutePath === fileLinkPath;
                        });
                        if (linkedFileNode) {
                          addPageDependency({
                            path: context.path,
                            nodeId: linkedFileNode.id
                          });
                          return linkedFileNode;
                        }
                      }

                      // Next assume the field is using the ___TYPE notation.
                      var linkedType = _.capitalize(fieldName.split(`___`)[1]);
                      if (fieldValue) {
                        // First assume the user is linking using the desired node's ID.
                        // This is a temp hack but then assume the link is a relative path
                        // and try to resolve it. Probably a better way is that each typegen
                        // plugin can define a custom resolve function which handles special
                        // logic for alternative ways of adding links between nodes.
                        var _linkedFileNode = void 0;
                        //linkedFileNode = select(dataTree, `${linkedType}[id="${node[fieldName]}"]`)[0]
                        _linkedFileNode = _.find(getNodes(), function (n) {
                          return n.type === linkedType && n.id === node[fieldName];
                        });

                        if (_linkedFileNode) {
                          addPageDependency({
                            path: context.path,
                            nodeId: _linkedFileNode.id
                          });
                          return _linkedFileNode;
                        } else if (linkedType === `File`) {
                          var _fileLinkPath = slash(path.resolve(sourceFileNode.dir, node[fieldName]));
                          _linkedFileNode = _.find(getNodes(), function (n) {
                            return n.type === `File` && n.id === _fileLinkPath;
                          });

                          if (_linkedFileNode) {
                            addPageDependency({
                              path: context.path,
                              nodeId: _linkedFileNode.id
                            });
                            return _linkedFileNode;
                          } else {
                            console.error(`Unable to load the linked ${linkedType} for`, node);
                            return null;
                          }
                        } else {
                          console.error(`Unable to load the linked ${linkedType} for`, node);
                          return null;
                        }
                      } else {
                        return null;
                      }
                    }
                  };

                  processedTypes[_.camelCase(typeName)] = nodeType;
                  typeResolve();
                });
              });
            })).then(function () {
              return resolve(processedTypes);
            });
          }));

        case 1:
        case "end":
          return _context.stop();
      }
    }
  }, _callee, undefined);
}));