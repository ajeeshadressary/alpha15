"use strict";

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _extends2 = require("babel-runtime/helpers/extends");

var _extends3 = _interopRequireDefault(_extends2);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var buildSchema = function () {
  var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
    var typesGQL, connections, schema;
    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            console.time(`building schema`);
            _context.next = 3;
            return buildNodeTypes();

          case 3:
            typesGQL = _context.sent;
            connections = buildNodeConnections(_.values(typesGQL));
            schema = new GraphQLSchema({
              query: new GraphQLObjectType({
                name: `RootQueryType`,
                fields: function fields() {
                  return (0, _extends3.default)({}, _.mapValues(typesGQL, `node`), connections, siteSchema());
                }
              })
            });


            console.timeEnd(`building schema`);
            store.dispatch({
              type: `SET_SCHEMA`,
              payload: schema
            });

            return _context.abrupt("return");

          case 9:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function buildSchema() {
    return _ref.apply(this, arguments);
  };
}();

// This seems like the most sensible way to decide when the the initial
// search for nodes is finished. At least for filesystem based nodes. For
// source plugins pulling from remote systems, there'll probably need to be
// an explicit API for them to let Gatsby core know that a sync is complete.


function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ = require("lodash");
var parents = require("unist-util-parents");

var _require = require("graphql"),
    GraphQLSchema = _require.GraphQLSchema,
    GraphQLObjectType = _require.GraphQLObjectType;

var siteSchema = require("./site-schema");
var apiRunner = require("../utils/api-runner-node");
var buildNodeTypes = require("./build-node-types");
var buildNodeConnections = require("./build-node-connections");

var _require2 = require("../redux"),
    store = _require2.store;

var debounceNodeCreation = function debounceNodeCreation(cb) {
  var updateNode = _.debounce(cb, 250);
  // Ensure schema is created even if the project hasn't got any source plugins.
  updateNode();
  store.subscribe(function () {
    var state = store.getState();
    if (state.lastAction.type === "CREATE_NODE" || state.lastAction.type === `UPDATE_NODE` || state.lastAction.type === `UPDATE_SOURCE_PLUGIN_STATUS`) {
      updateNode();
    }
  });
};

module.exports = function () {
  return new _promise2.default(function (resolve) {
    console.time(`sourcing and parsing nodes`);
    apiRunner(`sourceNodes`);
    var builtSchema = false;
    debounceNodeCreation(function () {
      var state = store.getState();
      // Check if the schema has been built yet and if
      // all source plugins have reported that they're ready.
      if (!builtSchema && _.every(_.values(state.status))) {
        console.timeEnd(`sourcing and parsing nodes`);
        builtSchema = true;
        // Resolve promise once the schema is built.
        buildSchema().then(function () {
          return resolve();
        });
      }
    });
  });
};