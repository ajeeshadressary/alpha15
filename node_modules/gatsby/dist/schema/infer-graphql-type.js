"use strict";

var _keys = require("babel-runtime/core-js/object/keys");

var _keys2 = _interopRequireDefault(_keys);

var _extends2 = require("babel-runtime/helpers/extends");

var _extends3 = _interopRequireDefault(_extends2);

var _objectWithoutProperties2 = require("babel-runtime/helpers/objectWithoutProperties");

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _require = require("graphql"),
    GraphQLObjectType = _require.GraphQLObjectType,
    GraphQLBoolean = _require.GraphQLBoolean,
    GraphQLString = _require.GraphQLString,
    GraphQLFloat = _require.GraphQLFloat,
    GraphQLInt = _require.GraphQLInt,
    GraphQLList = _require.GraphQLList;

var _ = require("lodash");
var moment = require("moment");
var parseFilepath = require("parse-filepath");
var mime = require("mime");
var isRelative = require("is-relative-url");

var _require2 = require("../redux"),
    store = _require2.store,
    getNodes = _require2.getNodes;

var _require3 = require("../redux/actions/add-page-dependency"),
    addPageDependency = _require3.addPageDependency;

var inferGraphQLType = function inferGraphQLType(_ref) {
  var value = _ref.value,
      fieldName = _ref.fieldName,
      otherArgs = (0, _objectWithoutProperties3.default)(_ref, ["value", "fieldName"]);

  if (Array.isArray(value)) {
    var headType = inferGraphQLType({ value: value[0], fieldName }).type;
    return { type: new GraphQLList(headType) };
  }

  if (value === null) {
    return null;
  }

  // Check if this is a date.
  // All the allowed ISO 8601 date-time formats used.
  var ISO_8601_FORMAT = [`YYYY`, `YYYY-MM`, `YYYY-MM-DD`, `YYYYMMDD`, `YYYY-MM-DDTHHZ`, `YYYY-MM-DDTHH:mmZ`, `YYYY-MM-DDTHHmmZ`, `YYYY-MM-DDTHH:mm:ssZ`, `YYYY-MM-DDTHHmmssZ`, `YYYY-MM-DDTHH:mm:ss.SSSZ`, `YYYY-MM-DDTHHmmss.SSSZ`, `YYYY-[W]WW`, `YYYY[W]WW`, `YYYY-[W]WW-E`, `YYYY[W]WWE`, `YYYY-DDDD`, `YYYYDDDD`];
  var momentDate = moment.utc(value, ISO_8601_FORMAT, true);
  if (momentDate.isValid()) {
    return {
      type: GraphQLString,
      args: {
        formatString: {
          type: GraphQLString
        },
        fromNow: {
          type: GraphQLBoolean,
          description: `Returns a string generated with Moment.js' fromNow function`
        },
        difference: {
          type: GraphQLString,
          description: `Returns the difference between this date and the current time. Defaults to miliseconds but you can also pass in as the measurement years, months, weeks, days, hours, minutes, and seconds.`
        }
      },
      resolve(object, _ref2) {
        var fromNow = _ref2.fromNow,
            difference = _ref2.difference,
            formatString = _ref2.formatString;

        var date = object[fieldName];
        if (formatString) {
          return moment.utc(date, ISO_8601_FORMAT, true).format(formatString);
        } else if (fromNow) {
          return moment.utc(date, ISO_8601_FORMAT, true).fromNow();
        } else if (difference) {
          return moment().diff(moment.utc(date, ISO_8601_FORMAT, true), difference);
        } else {
          return date;
        }
      }
    };
  }

  switch (typeof value) {
    case `boolean`:
      return { type: GraphQLBoolean };
    case `string`:
      return { type: GraphQLString };
    case `object`:
      return {
        type: new GraphQLObjectType({
          name: _.camelCase(fieldName),
          fields: inferObjectStructureFromNodes((0, _extends3.default)({
            selector: fieldName
          }, otherArgs))
        })
      };
    case `number`:
      return value % 1 === 0 ? { type: GraphQLInt } : { type: GraphQLFloat };
    default:
      return null;
  }
};

// Call this for the top level node + recursively for each sub-object.
// E.g. This gets called for Markdown and then for its frontmatter subobject.
var inferObjectStructureFromNodes = exports.inferObjectStructureFromNodes = function (_ref3) {
  var nodes = _ref3.nodes,
      selector = _ref3.selector,
      types = _ref3.types,
      allNodes = _ref3.allNodes;

  var type = nodes[0].type;
  var fieldExamples = {};
  _.each(nodes, function (node) {
    var subNode = void 0;
    if (selector) {
      subNode = _.get(node, selector);
    } else {
      subNode = node;
    }
    _.each(subNode, function (v, k) {
      if (!fieldExamples[k]) {
        fieldExamples[k] = v;
      }
    });
  });

  // Remove fields common to the top-level of all nodes.  We add these
  // elsewhere so don't need to infer there type.
  if (!selector) {
    delete fieldExamples.type;
    delete fieldExamples.id;
    delete fieldExamples.parent;
    delete fieldExamples.children;
  }

  var config = store.getState().config;
  var mapping = void 0;
  if (config) {
    mapping = config.mapping;
  }
  var inferredFields = {};
  _.each(fieldExamples, function (v, k) {
    // Check if field is pointing to custom type.
    // First check field => type mappings in gatsby-config.js
    var fieldSelector = _.remove([nodes[0].type, selector, k]).join(".");
    if (mapping && _.includes((0, _keys2.default)(mapping), fieldSelector)) {
      var matchedTypes = types.filter(function (type) {
        return type.name === mapping[fieldSelector];
      });
      if (_.isEmpty(matchedTypes)) {
        console.log(`Couldn't find a matching node type for "${fieldSelector}"`);
        return;
      }
      var findNode = function findNode(fieldValue, path) {
        var linkedType = mapping[fieldSelector];
        console.log("findNode", linkedType, fieldValue);
        var linkedNode = _.find(getNodes(), function (n) {
          return n.type === linkedType && n.id === fieldValue;
        });
        if (linkedNode) {
          addPageDependency({ path, nodeId: linkedNode.id });
          return linkedNode;
        }
      };
      if (_.isArray(v)) {
        inferredFields[k] = {
          type: new GraphQLList(matchedTypes[0].nodeObjectType),
          resolve: function resolve(node, a, b, _ref4) {
            var fieldName = _ref4.fieldName;

            var fieldValue = node[fieldName];

            if (fieldValue) {
              return fieldValue.map(function (value) {
                return findNode(value, b.path);
              });
            } else {
              return null;
            }
          }
        };
      } else {
        console.log(matchedTypes);
        inferredFields[k] = {
          type: matchedTypes[0].nodeObjectType,
          resolve: function resolve(node, a, b, _ref5) {
            var fieldName = _ref5.fieldName;

            var fieldValue = node[fieldName];

            if (fieldValue) {
              return findNode(fieldValue, b.path);
            } else {
              return null;
            }
          }
        };
      }
    } else if (_.includes(k, `___`)) {
      var fieldType = _.capitalize(k.split(`___`)[1]);
      var matchedType = _.find(types, function (type) {
        return type.name === fieldType;
      });
      if (matchedType) {
        inferredFields[k] = matchedType.field;
      }

      // Special case fields that look like they're pointing at a file â€” if the
      // field has a known extension then assume it should be a file field.
    } else if (nodes[0].type !== `File` && _.isString(v) && mime.lookup(v) !== `application/octet-stream` && isRelative(v)) {
      var fileNodes = types.filter(function (type) {
        return type.name === `File`;
      });
      if (fileNodes && fileNodes.length > 0) {
        inferredFields[k] = fileNodes[0].field;
      }
    } else {
      inferredFields[k] = inferGraphQLType({
        value: v,
        fieldName: k,
        nodes,
        types,
        allNodes: getNodes()
      });
    }
  });

  return inferredFields;
};